# Dynamic Programming

## Knapsack Problem

**有N件物品和一个容量为V的背包。第i件物品的体积是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。**

### 01 Knapsack

01背包对可选物品限制每个**只能被选一次**，被选过之后就不能再被选了。

动态规划典型解法，**dp[i, j]表明前i个物品放入容量为j的包中的最大价值**。

对于一个第i个物品，只有两种可能，

- 不放入：dp[i, j] = dp[i-1, j]
- 放入: dp[i, j] = **dp[i-1, j-w[i]] + c[i]**  if j-w[i] > 0

故转化方程为：

**dp[i, j] = MAX( dp[i-1, j],   dp[i-1, j-w[i]]+c[i] )**

### 完全背包问题

完全背包对物品选取没有次数限制，每种物品都可以被选中无数次。

这里的转换方程基本和01背包一致，需要注意的是，对于放入这种情形是可以放入多件的

- 不放入：dp[i, j] = dp[i-1, j]
- 放入: dp[i, j] = dp[i-1, j-k\*w[i]] + k\*c[i]  , 0<k<=j/w[i]

故转化方程为：

**dp[i, j] = MAX( dp[i-1, j-k\*w[i]]+k\*c[i] )**  for  0<k<=j/w[i] and j-k*w[i] > 0

### 部分背包问题

部分背包对物品选举的是有次数限制的，对于第i个物品最多被选入n[i] 次，转换方程类似完全背包

**dp[i, j] = MAX( dp[i-1, j-k\*w[i]]+k\*c[i] )**  for  0<k<=**n[i]** and j-k*w[i] > 0



## 分治、动态规划、贪心算法、递归的区别

### 分治

将原问题分解为若干个规模较小但类似于原问题的子问题（Divide），递归的求解这些子问题（Conquer），然后再合并这些子问题的解来建立原问题的解。**求解时使用的方法一般是递归实现**。

### 动态规划

动态规划和分治法思想相似，利用动态规划的问题一般是分治法也可以解决，不过动态规划的有如下特点：

- 重叠子问题
- **最优子结构**

当有重叠子问题时，如果使用单纯递归（分治法）就会导致重复计算，所以可以采用memorization记录**递归**求解过程中子问题的结果，这就是动态规划中的自顶向下的解决方法。

另一种方式就是自底向上，找出**状态转移方程**，迭代求出结果。

### 贪心算法

贪心算法每一步都根据策略得到一个当前最优结果结果，并传递到下一步，自顶向下，一步一步地做出贪心决策。

当该问题具有贪心选择性质（我们可以通过求出局部最优来构造全局最优）的时候，我们就可以用贪心算法来解决该问题。

### 递归

通过上面的讨论也可以发现，递归其实是一种实现方式，分治法、动态规划、贪心算法都可以用递归实现。

## Tips

- 动态规划问题需要考虑清楚 **转换公式** 和 **初始化的值**